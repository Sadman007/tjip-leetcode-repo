//1. Two Sum

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int sz = nums.size();
        map<int, int> mp;
        //for(int i = 0; i < sz; i++) mp[nums[i]] = i;
        for(int i = 0; i < sz; i++){
            if(mp.find(target - nums[i]) != mp.end() && i != mp[target-nums[i]]){
                return {i, mp[target-nums[i]]};
            }mp[nums[i]] = i;
        }
        return {};
    }
};



//15. 3Sum

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int n = nums.size();
        for(int i = 0; i < n-2; i++){
            
            int lft = i+1, rht = n-1;
            while(lft < rht){
                if(nums[i] + nums[lft] + nums[rht] == 0) {
                    vector<int> v;
                    v.push_back(nums[i]);
                    v.push_back(nums[lft]);
                    v.push_back(nums[rht]);
                    res.push_back(v);
                    while(lft < rht-1 && nums[lft] == nums[lft+1]) lft++;
                    while(rht > lft && nums[rht] == nums[rht-1]) rht--; 
                }
                
                int rem = 0 - nums[i];
                if(rem < nums[lft] + nums[rht]) rht--;
                else lft++;
            }
            while(i < n-1 && nums[i] == nums[i+1]) i++;
        }
        return res;
    }
};


//41. First Missing Positive
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int res = 1, sz = nums.size();
        for(int i = 0; i < sz; i++) {
            if(nums[i] == 1) res = 2;
            if(nums[i] <= 0) nums[i] = 1;
        }
        if(res != 1){
            for(int i = 0; i < sz; i++){
                int cur = abs(nums[i]);
                 if(cur && cur <= sz and nums[cur-1] > 0) {
                    nums[cur-1] = -nums[cur-1];
                }
            }
        }
        else return 1;
        for(int i = 0; i < sz; i++) if(nums[i] >= 0) return i+1;
        return sz+1;
    }
};



//56. Merge Intervals

class Solution {
    public:
        vector<vector<int>> merge(vector<vector<int>>& intervals) {
        set<int> points;
        unordered_map<int, int> mp, isLft, revMp;
        int sz = intervals.size();
        for(int i = 0; i < sz; i++){
            int lft = intervals[i][0], rht = intervals[i][1];
            isLft[lft] = 1;
            points.insert(lft);
            points.insert(rht);
        }
        int k = 0;
        for(int it : points){
            if(isLft.count(it)){ //key hisebe it thakle 1 return korbe
                k += 2;
                mp[it] = k;
            }
            else mp[it] = ++k;
            revMp[k] = it;
        }
        int LIM = 100000;
        int dif[LIM+5];
        memset(dif, 0, sizeof dif);
        for(int i = 0; i < sz; i++){
            int lft = mp[intervals[i][0]], rht = mp[intervals[i][1]];
            dif[lft] += 1;
            dif[rht+1] -= 1;
        }
        for(int i = 1; i <= LIM; i++) dif[i] += dif[i-1];
        vector< vector<int> > res;
        k = 2;
        while(k < LIM){
            while(dif[k] == 0 && k <= LIM) k++;
            int lft = k;
            while(dif[k] && k <= LIM) k++;
            int rht = k-1;
            if(k > LIM) break;
            res.push_back({revMp[lft], revMp[rht]});
        }

        return res;
    }
};



//42. Trapping Rain Water

class Solution {
public:
    int trap(vector<int>& height) {
        deque<int> dq;
        int sz = height.size();
        if(!sz) return 0;
        dq.push_front(height[0]);
        int last = height[0], res = 0;
        for(int i = 1; i < sz; i++){
            int cur = height[i];
            if(cur >= last){
                while(dq.size()){
                    int top = dq.front(); dq.pop_front();
                    res += last - top;
                }
                dq.push_front(cur);
                last = cur;
            }
            else dq.push_front(cur);
        }
        while(dq.size()){
            int last = dq.front(); dq.pop_front();
            while(dq.size()){
                int top = dq.front();
                if(top < last){
                    res += last - top;
                    dq.pop_front();
                }
                else break;
            }
        }
        return res;
    }
};



//136. Single Number

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < nums.size(); i++) res ^= nums[i];
        
        return res;
    }
};



//169. Majority Element

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int winner = 0, vote = 0;
        for(int i = 0; i < nums.size(); i++){
            if(vote == 0){
                winner = nums[i];
                vote = 1;
            }
            else if(winner != nums[i]) --vote;
            else ++vote;
        }
        return winner;
    }
};



//128. Longest Consecutive Sequence
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> bucket(nums.begin(), nums.end());
        int mxLen = 0;
        for(int num : bucket){
            if(!bucket.count(num-1)){
                int cur = num;
                while(bucket.count(cur)) cur++;
                mxLen = max(mxLen, cur - num);
            }
        }
        return mxLen;
    }
};
